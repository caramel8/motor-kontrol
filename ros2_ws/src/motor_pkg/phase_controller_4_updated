#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import Int32MultiArray

def wrap_err(a, b, M):
    # a-b farkını dairesel eksende [-M/2, M/2)
    return (a - b + M//2) % M - M//2

class PhaseLockPD(Node):
    def __init__(self):
        super().__init__('pd_controller_phase_lock')

        # === Parametreler ===
        self.cpr        = int(self.declare_parameter('cpr', 2000).value)
        self.phase_deg  = float(self.declare_parameter('phase_deg', 30.0).value)
        # Mutlak hedefi Motor 4 kullanacak; geriye dönük uyum için 'target1' ismini korunmuş tuttum
        self.target1    = int(self.declare_parameter('target1', 1000).value)

        # Kazançlar
        self.kp_abs     = float(self.declare_parameter('kp_abs', 0.10).value)
        self.kd_abs     = float(self.declare_parameter('kd_abs', 0.05).value)
        self.kp_phase   = float(self.declare_parameter('kp_phase', 0.15).value)
        self.kd_phase   = float(self.declare_parameter('kd_phase', 0.06).value)

        # Şekillendirme
        self.dead       = float(self.declare_parameter('dead', 20.0).value)
        self.min_run    = float(self.declare_parameter('min_run', 40.0).value)
        self.log        = bool(self.declare_parameter('log', True).value)

        # Faz offset (counts) — “geride” varsayımıyla ref = ang4 - offset
        self.offset_counts = round(self.cpr * self.phase_deg / 360.0)

        # Durum
        self.prev_err_abs = 0.0           # Motor4 için
        self.prev_err_phase = [0.0, 0.0, 0.0]  # M1, M2, M3 için
        self.prev_t = None

        # ROS I/O
        self.sub_enc = self.create_subscription(Int32MultiArray, 'encoder_data', self.enc_cb, 10)
        self.pub_cmd = self.create_publisher(Int32MultiArray, 'motor_cmd', 10)

        self.get_logger().info(
            f"Phase-Lock PD ready | cpr={self.cpr}, phase_deg={self.phase_deg} "
            f"(offset={self.offset_counts}), target4={self.target1} | "
            f"kp_abs={self.kp_abs}, kd_abs={self.kd_abs}, kp_phase={self.kp_phase}, kd_phase={self.kd_phase} | "
            f"dead={self.dead}, min_run={self.min_run}"
        )

    def _sat(self, u: float, lo=-100.0, hi=100.0) -> float:
        return hi if u > hi else lo if u < lo else u

    def _shape(self, u: float) -> int:
        # |u| < dead -> 0 ; dead <= |u| < min_run -> sign*min_run ; else -> sat(u)
        s = 1 if u >= 0 else -1
        a = abs(u)
        if a < self.dead:
            return 0
        if a < self.min_run:
            return int(s * self.min_run)
        return int(self._sat(u, -100.0, 100.0))

    def enc_cb(self, msg: Int32MultiArray):
        data = list(msg.data)
        if len(data) < 4:
            data += [data[-1] if data else 0] * (4 - len(data))
        pos1, pos2, pos3, pos4 = [int(x) for x in data[:4]]

        # dt
        now = self.get_clock().now().nanoseconds * 1e-9
        if self.prev_t is None:
            self.prev_t = now
            return
        dt = now - self.prev_t
        if dt <= 0:
            dt = 1e-3
        self.prev_t = now

        # --- Motor4: mutlak hedefe PD (referans motor) ---
        err_abs  = self.target1 - pos4
        derr_abs = (err_abs - self.prev_err_abs) / dt
        u4       = self.kp_abs * err_abs + self.kd_abs * derr_abs
        self.prev_err_abs = err_abs

        # Açıları [0, cpr) aralığına indir
        ang1 = pos1 % self.cpr
        ang2 = pos2 % self.cpr
        ang3 = pos3 % self.cpr
        ang4 = pos4 % self.cpr

        # Referanslar:
        ref1  = ang4                                  # M1 = M4 ile aynı faz
        ref23 = (ang4 - self.offset_counts) % self.cpr  # M2 = M3 = M4'ten phase_deg geride

        # --- Motor1 faz PD (ang1 -> ref1) ---
        e1   = wrap_err(ang1, ref1, self.cpr)
        de1  = (e1 - self.prev_err_phase[0]) / dt
        u1   = self.kp_phase * e1 + self.kd_phase * de1
        self.prev_err_phase[0] = e1

        # --- Motor2 faz PD (ang2 -> ref23) ---
        e2   = wrap_err(ang2, ref23, self.cpr)
        de2  = (e2 - self.prev_err_phase[1]) / dt
        u2   = self.kp_phase * e2 + self.kd_phase * de2
        self.prev_err_phase[1] = e2

        # --- Motor3 faz PD (ang3 -> ref23) ---
        e3   = wrap_err(ang3, ref23, self.cpr)
        de3  = (e3 - self.prev_err_phase[2]) / dt
        u3   = self.kp_phase * e3 + self.kd_phase * de3
        self.prev_err_phase[2] = e3

        # Şekillendir ve yayınla
        u1 = self._shape(u1)
        u2 = self._shape(u2)
        u3 = self._shape(u3)
        u4 = self._shape(u4)

        out = Int32MultiArray()
        out.data = [u1, u2, u3, u4]
        self.pub_cmd.publish(out)

        if self.log:
            self.get_logger().info(
                f"u=[{u1},{u2},{u3},{u4}] | ang=[{ang1},{ang2},{ang3},{ang4}] | ref1={ref1} ref23={ref23}"
            )

def main(args=None):
    rclpy.init(args=args)
    node = PhaseLockPD()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
